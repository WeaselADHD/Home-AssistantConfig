blueprint:
  name: 🔥 Advanced Heating Control
  author: panhans
  homeassistant:
    min_version: "2024.2.0"
  description: "



    🔥 heating / ❄ based on


    > 👥 people presence

    🗓️ multiple schedulers

    🚶 presence sensor

    ↔️ proximity aka geo fencing


    🥶 frost protection

    😡 adjustable aggressive mode

    🌤️ activation based on weather, temperature or boolean entities

    🎛️ granular schedule adjustments

    🪟 multiple window open detection

    🎈 party mode

    🤝 guest mode

    🧭 thermostat calibration for the most common devices (Tado, Aqara, Popp / Danfoss / Hive, Tuya)

    ⚙️ several tweaks for fixing your thermostat issues

    🎬 custom action

    🤫 calm & 💪 reliable



    **Version**: 4.2.5

    **Help & FAQ**: [Advanced Heating Control](https://community.home-assistant.io/t/advanced-heating-control)

    **Documentation:** work in progress


    [![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/Q5Q3QEH52)

    "
  source_url: https://github.com/panhans/HomeAssistant/blob/dev_v4/blueprints/automation/panhans/heating_control.yaml
  domain: automation
  input:
    input_trvs:
      name: 🔥 Thermostats / Climates
      description: >
        `thermostats` `climates` 


        [Thermostats / Climates](https://www.home-assistant.io/integrations/climate/) to be controlled.
      selector:
        entity:
          filter:
            - domain:
                - climate
          multiple: true

    input_hvac_mode:
      name: 🎛️ Operation / HVAC Mode
      description: >
        `hvac`


        Select the hvac mode for your [thermostats](https://www.home-assistant.io/integrations/climate/). Be sure your selected thermostats support the hvac mode you've chosen.
        AHC will log a warning if there is a miss match. For radiator [thermostats]((https://www.home-assistant.io/integrations/climate/)) the default is mostly *heat*.
        If you own an air conditioner it will support *auto* or *cool*, too. 
      default: 'heat'
      selector:
        select:
          options:
            - heat
            - cool
            - auto
            - heat_cool

    input_temperature_minimum_static:
      name: 🌱 Static Eco Temperature
      description: >
        `eco temperature`


        The temperature that is set when your heating schedule is not active.
      default: 19
      selector:
        number:
          min: 4.0
          max: 75.0
          step: 0.5
          mode: box
          unit_of_measurement: °C / °F

    input_temperature_minimum:
      name: 🌱 Eco Temperature
      description: >
        `eco temperature` `optional`


        To control your eco temperature via automations or the UI, you can specify an *[input_number](https://www.home-assistant.io/integrations/input_number/)* entity here.


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_number
          multiple: false

    # C O M F O R T   &   M O D S
    input_temperature_comfort_static:
      name: 🛋️ Static Comfort Temperature
      description: >
        `comfort temperature`


        You can set a static comfort temperature here.
      default: 22
      selector:
        number:
          min: 12.0
          max: 86.0
          step: 0.5
          mode: box
          unit_of_measurement: °C / °F

    input_temperature_comfort:
      name: 🛋️ Comfort Temperature
      description: >
        `comfort temperature` `optional`


        To control your comfort temperature via automations or the UI, you can specify an *[input_number](https://www.home-assistant.io/integrations/input_number/)* entity here.


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_number
          multiple: false

    input_time_based_temperature_change_valve_target:
      name: 🎛️ Heating Schedule Adjustments
      description: >
        `optional`


        Here you can setup some adjustments to your heating schedule. What's possible until now?
        <br/>

        > 🕔 **time**

        > Timestamp when the adjustment should kick in. (required)


        > 📆 **days**

        > Select days where this setting shall be enabled.

        > ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']


        > 🗓️ **scheduler**

        > Only enable this entry if this string is part of the name of your active scheduler.


        > 🛋️ **comfort**

        > Adjust comfort temperature


        > 🌱 **eco**

        > Adjust eco temperature


        > 🧭 **calibration**

        > Toggle calibration 

        > on/off


        Example:
        <br/>

        ```yaml

        - time: "08:00"
          comfort: "20"
          calibration: "off"
        - time: "16:00"
          eco: "19"
          calibration: "on"
        - time: "20:00"
          days: ['Sat','Sun']
          scheduler: 'Holidays'
          comfort: "24"
          eco: "17"
        ```

      selector:
        object:
      default: "[]"

    # P E R S O N S
    input_persons:
      name: 👥 People
      description: >
        `people` `optional`


        You can specify [people](https://www.home-assistant.io/integrations/person/) to make your heating plan more dynamic. If you do not use [schedulers](https://www.home-assistant.io/integrations/schedule/) or presence sensors, heating is activated as soon as someone is at home.<br/>
        With [schedulers](https://www.home-assistant.io/integrations/schedule/) or presence sensors, these are only active when someone is at home.
      default: []
      selector:
        entity:
          filter:
            - domain:
                - person
          multiple: true

    input_people_entering_home_duration:
      name: 🏠 Enter Home Duration
      description: >
        `people`


        Duration for which someone must be at home for heating to be activated.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    input_people_leaving_home_duration:
      name: 💨 Leaving Home Duration
      description: >
        `people`


        Duration for which someone must be out of the house for heating to be deactivated.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    # P R O X I M I T Y
    input_proximity:
      name: ↔️ Proximity
      description: >
        `proximity` `optional`


        You can preheat your rooms with help of home assistant's [proximity integration](https://www.home-assistant.io/integrations/proximity/).<br/>
        Just select your proxmity zone and take your adjustments to distance and duration.<br/>
        If you're in range of your distance and towards to your home heating kicks in. If you don't specify any scheduler or presence detector heating also is enabled if you arrived.<br/>

        **Note**: If *on way home* is detected this gets handled like presence is on or somebody is home. So this has to match with the states of your schedulers if you use them.
      default: ""
      selector:
        device:
          filter:
            integration: proximity
          multiple: false

    input_proximity_duration:
      name: ⏰ Proximity Duration
      description: >
        `proximity`


        Duration for which someone must be on way home before heating occurs.
      default:
        hours: 0
        minutes: 2
        seconds: 0
      selector:
        duration:

    input_proximity_distance:
      name: ↔️ Proximity Distance
      description: >
        `proximity`


        The distance when proximity sensor gets impact for this automation. Hint: Unit depends on the setup of your integration.
      default: 500
      selector:
        number:
          min: 0
          max: 999999999
          step: 1
          mode: box

    # S C H E D U L E R
    input_schedulers:
      name: ⏲️ Scheduler
      description: >
        `scheduler` `optional`


        A [scheduler](https://www.home-assistant.io/integrations/schedule/) specifies when heating to comfort temperature should take place. You can create it in the helper section of Home Assistant.<br/>
        If you have also specified [people](https://www.home-assistant.io/integrations/person/), someone must also be at home for heating.<br/>
        You can create as many [schedulers](https://www.home-assistant.io/integrations/schedule/) as you like. Make sure the names are clear.


        Create your scheduler [here](https://my.home-assistant.io/redirect/helpers/).
      default: []
      selector:
        entity:
          filter:
            - domain:
                - schedule
          multiple: true

    input_scheduler_selector:
      name: ☝🏻 Scheduler Selector
      description: >
        `scheduler` `optional`


        Define an entity to choose from your schedulers. If you use one scheduler only you can ignore this. If you use more than one scheduler you have multiple possibilities to setup your selection: <br/>

        * toggle [input_boolean](https://www.home-assistant.io/integrations/input_boolean/) or [binary_sensor](https://www.home-assistant.io/integrations/binary_sensor/): If *off* the first defined [scheduler](https://www.home-assistant.io/integrations/schedule/) is active. If *on* the second [scheduler](https://www.home-assistant.io/integrations/schedule/) is active. More than two [schedulers](https://www.home-assistant.io/integrations/schedule/) cannot be selected with binary inputs.

        * text [input text](https://www.home-assistant.io/integrations/input_text/), drop down [input text](https://www.home-assistant.io/integrations/input_select/) or [sensor](https://www.home-assistant.io/integrations/sensor/):
          * The value has to match the friendly name of the selected [scheduler](https://www.home-assistant.io/integrations/schedule/) at least partially. Example: If you provide three [schedulers](https://www.home-assistant.io/integrations/schedule/) called *work*, *holiday/sick*, *guest* you can select the holiday [scheduler](https://www.home-assistant.io/integrations/schedule/) while setting the selection entity to *sick*, *holiday* or *holiday/sick*. This option is case insensitive.
          * You also can go with numbers: if you want to choose the first [scheduler](https://www.home-assistant.io/integrations/schedule/) the selector entity must return the number *1*. For the 2nd number *2* and so on.


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - input_text
                - input_number
                - input_select
          multiple: false

    # P R E S E N C E
    input_presence_sensor:
      name: 🚶 Presence Sensor / On/Off-Entity
      description: >
        `presence detection` `optional`


        If you specify a presence sensor, heating will take place if it detects presence.<br/>
        If you have specified [people](https://www.home-assistant.io/integrations/person/), at least one must also be at home. You also can select an [Input Boolean](https://www.home-assistant.io/integrations/input_boolean/) entity to realise a simple On/Off-Logic.
      default:
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
                - input_boolean
          multiple: false

    input_scheduler_presence:
      name: ⏲️ Presence Sensor Scheduler
      description: >
        `presence detection` `optional`


        The presence [scheduler](https://www.home-assistant.io/integrations/schedule/) specifies exactly when the presence sensor should be used during the day.
      default:
      selector:
        entity:
          filter:
            - domain:
                - schedule
          multiple: false

    input_presence_reaction_on_time:
      name: ⏳ Presence Reaction On Time
      description: >
        `presence detection`


        Specify the duration for which the presence sensor must detect any presence so that the comfort temperature is set.
      default:
        hours: 0
        minutes: 5
        seconds: 0
      selector:
        duration:

    input_presence_reaction_off_time:
      name: ⌛ Presence Reaction Off Time
      description: >
        `presence detection`


        Specify the duration for which the presence sensor must not detect any presence so that the minimum temperature is set.
      default:
        hours: 0
        minutes: 5
        seconds: 0
      selector:
        duration:

    # A W A Y   O F F S E T 
    input_away_offset:
      name: 🏃 Away Temperature
      description: >
        `scheduler` `persons` `presence` `away mode`


        First: This feature only works for [schedule](https://www.home-assistant.io/integrations/schedule/) and/or presence based heating combined with [people/persons](https://www.home-assistant.io/integrations/person/). You can define an offset for your comfort temperature that will be subtracted (heating) from or added (cooling) to your comfort temperature.

        If you enable this option for [scheduling](https://www.home-assistant.io/integrations/schedule/)  the away offset will be set if your scheduler is *on* but nobody is at home.
        For presence detection the offset will be set if you are at home but no presence is detected.
      default: 0
      selector:
        number:
          min: 0
          max: 10
          step: 0.5
          mode: slider
          unit_of_measurement: °C / °F

    input_away_options:
      name: ⚙️ Away Mode
      description: "
        `scheduler` `persons` `presence` `away mode`

        > ### ⏲️ Scheduler Away Mode

        > Enable/Disable the Away Offset for [scheduled](https://www.home-assistant.io/integrations/schedule/) based heating/cooling

        > ### 🚶 Presence Away Mode

        > Enable/Disable the Away Offset for presence based heating/cooling


        **NOTE:** Don't set temperature by your [climate](https://www.home-assistant.io/integrations/climate/) entities when using generic calibration but by your eco / comfort entities only in order to prevent unwanted side effect. (caused by a home assistant [bug](https://github.com/home-assistant/core/issues/99914))

        "

      default: []
      selector:
        select:
          options:
            - label: "⏲️ Scheduler Away Mode"
              value: scheduler
            - label: "🚶 Presence Away Mode"
              value: presence
          multiple: true
          custom_value: false
          mode: list

    # M O D E S
    input_mode_party:
      name: 🎈 Party mode
      description: >
        `optional`


        If on, all settings are ignored and heating takes place. You can define multiple [timers](https://www.home-assistant.io/integrations/timer/) or boolean entities.
        If you put a number at the end of the friendly name like *Party Timer 20* this number will be taken as the desired comfort temperature for this [timer](https://www.home-assistant.io/integrations/timer/).


        Create your timer [here](https://my.home-assistant.io/redirect/helpers/).
      default: []
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - timer
          multiple: true

    input_mode_guest:
      name: 🤝 Guest mode
      description: >
        `optional`



        If an entity is specified here, it is treated like a [person](https://www.home-assistant.io/integrations/person/). It's usefull when you're leaving your guests alone in your home and you are not using presence detection.
          
          * entity defined -> [person](https://www.home-assistant.io/integrations/person/) defined
          * enitity is *on* -> simulates [person](https://www.home-assistant.io/integrations/person/) is home
          * enitity is *off* -> simulates [person](https://www.home-assistant.io/integrations/person/) is away


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - timer
          multiple: false

    # W I N D O W   O P E N   D E T E C T I O N
    input_windows:
      name: 🪟 Windows & Doors
      description: >
        `airing` `optional`


        If open during airing your [thermostats](https://www.home-assistant.io/integrations/climate/) will be set to *off* at least to their minimum temperature if they don't support hvac mode *OFF*.
      default: []
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
          multiple: true

    input_windows_reaction_time_open:
      name: ⏳ Window & Door Reaction Time Open
      description: >
        `airing`


        Duration for which a window or door must be open for the [thermostats](https://www.home-assistant.io/integrations/climate/) to close.
      default:
        hours: 0
        minutes: 0
        seconds: 30
      selector:
        duration:

    input_windows_reaction_time_close:
      name: ⌛ Window & Door Reaction Time Close
      description: >
        `airing`  


        Duration for which a window or door must be closed for the [thermostats](https://www.home-assistant.io/integrations/climate/) to open.
      default:
        hours: 0
        minutes: 0
        seconds: 30
      selector:
        duration:

    # F R O S T   P R O T E C T I O N
    input_frost_protection_temp:
      name: ❄️ Frost Protection Temperature
      description: >
        `frost protection`


        You can set the frost protection temperature here.
      default: 5
      selector:
        number:
          min: 5.0
          max: 62.0
          step: 0.5
          mode: box
          unit_of_measurement: °C / °F

    input_frost_protection_duration:
      name: ❄️ Frost Protection Fallback Duration
      description: >
        `frost protection`


        If the defined [persons](https://www.home-assistant.io/integrations/person/) are not at home for a longer period of time or the presence sensor has no longer detected any presence, the frost protection temperature can be lowered after a this duration.
        Note: If set to zero frost protection temperature never will be set.
      default:
        days: 0
        hours: 0
        minutes: 0
        seconds: 0
      selector:
        duration:
          enable_day: true

    # C A L I B R A T I O N
    input_temperature_sensor:
      name: 🌡️ Calibration Temperature Sensor
      description: >
        `calibration` `optional`


        Temperature calibration for your [thermostats](https://www.home-assistant.io/integrations/climate/). The following is supported:

          * Tado, Aqara, Popp, Danfoss, Hive, Tuya
          * generic calibration

        Note: This is an additional sensor inside your room usually next to your favourite spot. [Thermostats](https://www.home-assistant.io/integrations/climate/) or its integration (e.g. Z2M or ZHA) except Tado should provide a seperate clibration enitity.
      default:
      selector:
        entity:
          filter:
            - domain:
                - sensor
              device_class:
                - temperature
          multiple: false

    input_calibration_timeout:
      name: ⏳ Calibration Timeout
      description: >
        `calibration`


        Define a timeout if you want to decrease the amount of calibration calls if temperature changes too much.
        At least the temperature of the external sensor or [thermostat](https://www.home-assistant.io/integrations/climate/) must stay for that duration before calibration gets triggered.

        **HINT:** A minimum timeout of 2s is recommended.
      default:
        hours: 0
        minutes: 1
        seconds: 0
      selector:
        duration:

    input_calibration_delta:
      name: ↔️ Calibration Delta
      description: >
        `calibration`


        If the difference between the [thermostat](https://www.home-assistant.io/integrations/climate/) temperature and the external sensor temperature is greater or less than the calibration delta the [thermostat](https://www.home-assistant.io/integrations/climate/) calibration will be triggered.<br/>
        The lower the delta the often calibration gets triggered.
      default: 0.5
      selector:
        number:
          min: 0
          max: 5
          step: 0.1
          mode: slider
          unit_of_measurement: °C / °F

    input_calibration_options:
      name: ⚙️ Calibration Tweaks
      description: "
        `calibration`

        > ### 🧭 Generic Calibration

        > Adds the difference between room and [thermostat](https://www.home-assistant.io/integrations/climate/) temperature to the target temperature.

        > ### 🌕 Fully Rounded Values

        > Enable this if you [thermostat](https://www.home-assistant.io/integrations/climate/) calibration entity accept floating values but only save them as integers.


        **NOTE:** Don't set temperature by your [climate](https://www.home-assistant.io/integrations/climate/) entities when using generic calibration but by your eco / comfort entities only in order to prevent unwanted side effect. (caused by a home assistant [bug](https://github.com/home-assistant/core/issues/99914))

        "

      default: []
      selector:
        select:
          options:
            - label: "🧭 Generic Calibration"
              value: generic_calibration
            - label: "🌕 Fully Rounded Values"
              value: rounded_values
          multiple: true
          custom_value: false
          mode: list

    # W I N T E R  M O D E
    input_mode_winter:
      name: ⛄ Winter Mode / Automation Toggle
      description: >
        `activation` `optional`


        If *on* the automation is active. If *off* your valves will set to *off* and the automation is going to sleep.
        You can set this up with:

          * [input boolean](https://www.home-assistant.io/integrations/input_boolean/)
          * [binary sensor](https://www.home-assistant.io/integrations/binary_sensor/)


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
          multiple: false

    input_mode_outside_temperature:
      name: 🌤️ Outside Temperature Sensor
      description: >
        `activation` `optional`


        You can control the switching on and off of your thermostats via the outside temperature. 
        To do this, select a temperature sensor or a weather entity and adjust the threshold below.

          * [weather entity](https://www.home-assistant.io/integrations/weather/)
          * [temperature sensor entity](https://www.home-assistant.io/integrations/sensor/

      default:
      selector:
        entity:
          filter:
            - domain:
                - weather
            - domain:
                - sensor
              device_class: temperature
          multiple: false

    input_mode_outside_temperature_threshold:
      name: 🎚️ Outside Temperature Threshold
      description: >
        `activation`


        If you'd select a temperature [sensor](https://www.home-assistant.io/integrations/sensor/) or a [weather entity](https://www.home-assistant.io/integrations/weather/) for controlling heating you can adjust the temperature threshold here.
        If the outside temperature falls below the threshold value, heating is activated.
      default: 15
      selector:
        number:
          min: 5
          max: 68
          step: 1
          mode: box
          unit_of_measurement: °C / °F

    # M O D I F I E R S
    input_aggressive_mode_range:
      name: 😡 Agressive Mode - Range
      description: >
        `aggressive mode` `tweak`


        Activate this option if your [thermostats](https://www.home-assistant.io/integrations/climate/) react slowly or only start to react at a large temperature difference between actual and set temperature.
        Define a range when your real target temperature shall be set. E.g. you target temperature is 20°C and your room temperature is 19.5°C.
        If your range is set to 0.5°C the real target temperature (20°C) will be set when room temperature is between 19.5°C and 20.5°C.
        If the room temperature is above or lower that range it gets some offset in order to force your [thermostat](https://www.home-assistant.io/integrations/climate/) to react. (see Aggressive Mode - Offset)

        **NOTE:** Don't set temperature by your [cliamte](https://www.home-assistant.io/integrations/climate/) entities when using aggressive mode but by your eco / comfort entities only in order to prevent unwanted side effect. (caused by a home assistant [bug](https://github.com/home-assistant/core/issues/99914))
      default: 0
      selector:
        number:
          min: 0
          max: 5
          step: 0.1
          mode: slider
          unit_of_measurement: °C / °F

    input_aggressive_mode_offset:
      name: 😡 Agressive Mode - Offset
      description: >
        `aggressive mode` `tweak`


        Here you can define the offset that will be added to your target temperature if the room temperature is not in range of your target temperature.
        If your room temperature is not in the defined range, e.g. 19.5°C - 20.5°C this offset will be added to your target temperature.
      default: 0
      selector:
        number:
          min: 0
          max: 5
          step: 0.5
          mode: slider
          unit_of_measurement: °C / °F

    # TWEAKS
    input_service_call_delay:
      name: ⚙️ Service Call Delay
      description: >
        `tweak`


        Some [thermostats](https://www.home-assistant.io/integrations/climate/) have problems with setting mode and temperature. You can try to increase the
        delay between the service calls. This could fix your problems.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    input_tweaks:
      name: ⚙️ Tweaks
      description: "
        `tweak`


        > ### ↩️ Reset Temperature

        > Reset your temperature after party ends or temperature go from comfort to eco

        > ### 🛑 Turn *OFF* Instead Of Eco Temperature

        > Turn off your [thermostats](https://www.home-assistant.io/integrations/climate/) instead of lower the temperature to eco temperature

        > ### ⬇️ Min Temperature Instead Of *OFF*

        > Lower the temperature instead of turning them *OFF*, e.g. during airing

        > ### ↕️ Off If Above/Below Room Temperature

        > Turns your [climate](https://www.home-assistant.io/integrations/climate/) entity *off* if the target temperature is below(cooling) / above(heating) the room temperature

        > ### 🇫 Fahrenheit

        > Enable this if your unit of measurement is Fahrenheit (untested)

        "

      default: []
      selector:
        select:
          options:
            - label: "↩️ Reset Temperature"
              value: reset_temperature
            - label: "🛑 Off Instead Of Eco"
              value: off_instead_min
            - label: "⬇️ Min Instead Of Off"
              value: not_off_but_min
            - label: "↕️ Off If Above/Below Room Temperature"
              value: heat_only_if_below_real_temp
            - label: "🇫 Fahrenheit"
              value: fahrenheit
          multiple: true
          custom_value: false
          mode: list

    # E X P E R I M E N T A L
    # input_tweaks_experimental:
    #   name: 🧪 Experimental Tweaks
    #   description: "
    #     `tweak`


    #     > ### 🌡️ Physical Temperature Change

    #     > Adjust the temperature via your thermostats.

    #     > ### 🎈 Start Party Timer On Physical Change

    #     > Start your party timer when you change the temperature via your thermostats.


    #     **HINT**: This features may won't work properly since there is a [bug](https://github.com/home-assistant/core/issues/99914) in home assistant.

    #     "

    #   default: []
    #   selector:
    #     select:
    #       options:
    #         - label: "🌡️ Physical Temperature Change"
    #           value: physical_temperature_change
    #         - label: "🎈 Start Party Timer On Physical Change"
    #           value: physical_party_timer
    #       multiple: true
    #       custom_value: false
    #       mode: list

    input_force_max_temperature:
      name: 🥵 Force Max Temperature
      description: >
        `optional`


        Set the maximum temperature of all [thermostats](https://www.home-assistant.io/integrations/climate/) regardless of any other settings.


        **HINT:** Implemented by developer for maintenance reasons. Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
          multiple: false

    # C U S T O M   A C T I O N
    input_custom_action:
      name: 🎬 Custom Action
      description: >
        `optional`


        This custom action gets executed with every temperature / mode change except calibration. If you want to control other devices just check states before doing a service call.
        Use the variable *is_heating* in your conditions. *True* means heating is active.
      default:
      selector:
        action:

    input_log_level:
      name: ✍️ Log Level
      description: ""
      default: debug
      selector:
        select:
          mode: dropdown
          options:
            - info
            - warning
            - error
            - debug

##################################################
############### T R I G G E R ####################
##################################################

trigger_variables:
  # M O D E S
  input_mode_winter: !input input_mode_winter
  input_mode_party: !input input_mode_party
  input_mode_guest: !input input_mode_guest
  input_force_max_temperature: !input input_force_max_temperature

  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_minimum: !input input_temperature_minimum
  input_time_based_temperature_change_valve_target: !input input_time_based_temperature_change_valve_target

  # S C H E D U L E R
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector
  input_scheduler_presence: !input input_scheduler_presence

  # A D D I T I O N A L   S E T T I N G S
  input_trvs: !input input_trvs
  input_windows: !input input_windows
  input_temperature_sensor: !input input_temperature_sensor
  input_persons: !input input_persons
  input_presence_sensor: !input input_presence_sensor
  input_calibration_timeout: !input input_calibration_timeout

  input_proximity: !input input_proximity
  input_proximity_duration: !input input_proximity_duration
  input_proximity_distance: !input input_proximity_distance

  input_mode_outside_temperature: !input input_mode_outside_temperature
  input_mode_outside_temperature_threshold: !input input_mode_outside_temperature_threshold

  input_frost_protection_duration: !input input_frost_protection_duration

  input_tweaks: !input input_tweaks
  is_heat_only_if_below_real_temp: "{{ 'heat_only_if_below_real_temp' in input_tweaks}}"

trigger:
  # S Y S T E M   T R I G G E R S
  - platform: homeassistant
    event: start
    id: temperature_change_hastart

  - platform: event
    event_type: automation_reloaded
    id: temperature_change_reload

  # S T A T E   T R I G G E R S
  # not implemented yet
  # - platform: state
  #   entity_id: !input input_trvs
  #   attribute: temperature
  #   for:
  #     seconds: 5
  #   id: temperature_change_valve_target

  # T E M P E R A T U R E   C H A N G E S
  - platform: template
    value_template: >
      {% if input_temperature_minimum != none %}
        {{ now() - states.input_number[input_temperature_minimum.split('.')[1]].last_updated >= timedelta(seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}
    id: temperature_change_eco

  - platform: template
    value_template: >
      {% if input_temperature_comfort != none %}
        {{ now() - states.input_number[input_temperature_comfort.split('.')[1]].last_updated >= timedelta(seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}
    id: temperature_change_comfort

  # S C H E D U L E R   O N / O F F
  - platform: template
    id: temperature_change_scheduler_on
    value_template: >
      {% set trigger_state = 'on' %}
      {% set selected_scheduler = '' %}

      {% if input_schedulers | count == 0 %}
        {% set selected_scheduler = '' %}
      {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
        {% set selected_scheduler = input_schedulers[0] %}
      {% elif input_schedulers | count > 1 %}
        {% set selected_scheduler = input_schedulers[0] %}
        {% set selector_value = states(input_scheduler_selector) %}

        {% if is_number(selector_value) %}
          {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
          {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
          {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
        {% elif selector_value in ['on','off'] %}
          {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
        {% else %}
          {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first | default(selected_scheduler) %}
        {% endif %}

      {% endif %}

      {{ iif(selected_scheduler != '', is_state(selected_scheduler, trigger_state), false) }}

  - platform: template
    id: temperature_change_scheduler_off
    value_template: >
      {% set trigger_state = 'off' %}
      {% set selected_scheduler = '' %}

      {% if input_schedulers | count == 0 %}
        {% set selected_scheduler = '' %}
      {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
        {% set selected_scheduler = input_schedulers[0] %}
      {% elif input_schedulers | count > 1 %}
        {% set selected_scheduler = input_schedulers[0] %}
        {% set selector_value = states(input_scheduler_selector) %}

        {% if is_number(selector_value) %}
          {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
          {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
          {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
        {% elif selector_value in ['on','off'] %}
          {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
        {% else %}
          {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first | default(selected_scheduler) %}
        {% endif %}

      {% endif %}

      {{ iif(selected_scheduler != '', is_state(selected_scheduler, trigger_state), false) }}

  # P E R S O N  P R E S E N C E
  - platform: template
    value_template: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count > 0 }}"
    for: !input input_people_entering_home_duration
    id: temperature_change_person_on

  - platform: template
    value_template: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count == 0 }}"
    id: temperature_change_person_off
    for: !input input_people_leaving_home_duration

  # P R O X I M I T Y
  - platform: template
    id: temperature_change_person_proximity_on
    value_template: >
      {% set proximity_entities = device_entities(input_proximity) %}
      {% set is_arrived = proximity_entities  | expand 
                                                | selectattr('attributes.device_class', 'eq', 'enum') 
                                                | map(attribute='entity_id') | select('is_state','arrived') 
                                                | list | count > 0 %}

      {% set entities_towards = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'enum') 
                                              | map(attribute='entity_id') | select('is_state','towards') 
                                              | list %}

      {% set entities_distances = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'distance')
                                              | map(attribute='entity_id')
                                              | list %}

      {% set result = namespace(is_towards=false) %}
      {% for t in entities_towards %}
        {% set name = t.split('_')[:-1] | join('_') %}
        {% set entities_distances_filtered = entities_distances | expand | selectattr('entity_id','search',name) | map(attribute='entity_id') | list %}
        {% if result.is_towards == false and entities_distances_filtered | count > 0 %}
          {% set result.is_towards = states(entities_distances_filtered | first) | int <= input_proximity_distance | int %}
        {% endif %}
      {% endfor %}
      {% set is_towards = result.is_towards %}
      {{ is_towards or is_arrived }}
    for: !input input_proximity_duration

  - platform: template
    id: temperature_change_person_proximity_off
    value_template: >
      {% set proximity_entities = device_entities(input_proximity) %}
      {% set is_arrived = proximity_entities  | expand 
                                                | selectattr('attributes.device_class', 'eq', 'enum') 
                                                | map(attribute='entity_id') | select('is_state','arrived') 
                                                | list | count > 0 %}

      {% set entities_towards = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'enum') 
                                              | map(attribute='entity_id') | select('is_state','towards') 
                                              | list %}

      {% set entities_distances = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'distance')
                                              | map(attribute='entity_id')
                                              | list %}

      {% set result = namespace(is_towards=false) %}
      {% for t in entities_towards %}
        {% set name = t.split('_')[:-1] | join('_') %}
        {% set entities_distances_filtered = entities_distances | expand | selectattr('entity_id','search',name) | map(attribute='entity_id') | list %}
        {% if result.is_towards == false and entities_distances_filtered | count > 0 %}
          {% set result.is_towards = states(entities_distances_filtered | first) | int <= input_proximity_distance | int %}
        {% endif %}
      {% endfor %}
      {% set is_towards = result.is_towards %}
      {{ is_towards == false and is_arrived == false }}
    for: !input input_proximity_duration

  # W I N D O W  O P E N
  - platform: template
    value_template: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count > 0 }}"
    for: !input input_windows_reaction_time_open
    id: temperature_change_window_on

  - platform: template
    value_template: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count == 0 }}"
    for: !input input_windows_reaction_time_close
    id: temperature_change_window_off

  # M O D E   -   W I N T E R
  - platform: template
    id: temperature_change_winter_mode_on
    value_template: >
      {% if input_mode_winter != none %}
        {{ states(input_mode_winter) == 'on' }}
      {% endif %}
    for:
      seconds: 2

  - platform: template
    id: temperature_change_winter_mode_off
    value_template: >
      {% if input_mode_winter != none %}
        {{ states(input_mode_winter) == 'off' }}
      {% endif %}
    for:
      seconds: 2

  # O U T S I D E   T E M P E R A T U R E
  - platform: template
    id: temperature_change_outside_on
    value_template: >
      {% if input_mode_outside_temperature != none %}
        {% set state = states(input_mode_outside_temperature) %}
        {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}
        {{ state | int <= input_mode_outside_temperature_threshold | int }}
      {% endif %}
    for:
      seconds: 2

  - platform: template
    id: temperature_change_outside_off
    value_template: >
      {% if input_mode_outside_temperature != none %}
        {% set state = states(input_mode_outside_temperature) %}
        {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}
        {{ state | int > input_mode_outside_temperature_threshold | int }}
      {% endif %}
    for:
      seconds: 2

  # M O D E   -   M A I N T A N A C E
  - platform: template
    id: temperature_change_force_max_temperature_on
    value_template: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'on') }}"
    for:
      seconds: 2

  - platform: template
    id: temperature_change_force_max_temperature_off
    value_template: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'off') }}"
    for:
      seconds: 2

  # M O D E   -   P A R T Y
  - platform: template
    id: temperature_change_party_on
    value_template: "{{ input_mode_party | expand | selectattr('state', 'in', ['active','on']) | list | count > 0 }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_mode_party | expand | selectattr('state', 'in', ['active','on']) | list | count == 0 }}"
    id: temperature_change_party_off
    for:
      seconds: 2

  # M O D E   -   G U E S T
  - platform: template
    id: temperature_change_person_guest_on
    value_template: "{{ input_mode_guest != none and states(input_mode_guest) in ['on','active'] }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_mode_guest != none and states(input_mode_guest) in ['off','idle','paused'] }}"
    id: temperature_change_person_guest_off
    for:
      seconds: 2

  # P R E S E N C E   S E N S O R
  - platform: template
    id: temperature_change_presence_on
    value_template: "{{ input_presence_sensor != none and is_state(input_presence_sensor, 'on') }}"
    for: !input input_presence_reaction_on_time

  - platform: template
    value_template: "{{ input_presence_sensor != none and is_state(input_presence_sensor, 'off') }}"
    id: temperature_change_presence_off
    for: !input input_presence_reaction_off_time

  # P R E S E N C E   S C H E D U L E R
  - platform: template
    id: temperature_change_presence_scheduler_on
    value_template: "{{ input_scheduler_presence != none and is_state(input_scheduler_presence, 'on') }}"
    for:
      seconds: 2

  - platform: template
    id: temperature_change_presence_scheduler_off
    value_template: "{{ input_scheduler_presence != none and is_state(input_scheduler_presence, 'off') }}"
    for:
      seconds: 2

  # E X T E R N A L  C A L I B R A T I O N   S E N S O R
  - platform: template
    id: calibration_sensor_change
    value_template: >
      {% if input_temperature_sensor != none %}
        {{ (now() - states.sensor[input_temperature_sensor.split('.')[1]].last_updated) >= timedelta(hours=input_calibration_timeout.hours, minutes=input_calibration_timeout.minutes, seconds=input_calibration_timeout.seconds) }}
      {% else %}
        {{ false }}
      {% endif %}

  - platform: state
    id: calibration_aggressive_mode_thermostat_change
    entity_id: !input input_trvs
    attribute: current_temperature
    for: !input input_calibration_timeout

  - platform: template
    id: calibration_popp_change
    value_template: >
      {% if input_temperature_sensor != none %}
        {{ (now() - states.sensor[input_temperature_sensor.split('.')[1]].last_updated) >= timedelta(hours=0, minutes=0, seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}

  - platform: template
    id: calibration_popp_ping
    value_template: >
      {% set has_valves_danfoss = input_trvs | select('is_device_attr', 'manufacturer', 'Danfoss') | list  %}
      {% set has_valves_popp = input_trvs | select('is_device_attr', 'manufacturer', 'Popp') | list %}
      {% set valves_hive = input_trvs | select('is_device_attr', 'manufacturer', 'Hive') | list %}

      {% set all_valves = has_valves_danfoss + has_valves_popp + valves_hive %}

      {% if all_valves | count == 0 or input_temperature_sensor == none %}
        {{ false }}
      {% else %}
        {{ now().strftime('%M') | int % 10 == 0 }}
      {% endif %}

  # C O M F O R T   T E M P   C H A N G E   B Y   T I M E
  - platform: template
    id: temperature_change_heating_adjustment
    value_template: "{{ now().strftime('%H:%M') in (input_time_based_temperature_change_valve_target | map(attribute='time') | list) }}"

  # F R O S T   P R O T E C T I O N
  - platform: template
    id: temperature_change_frost_protection_on
    value_template: >
      {% set is_frost_protection_configured = input_frost_protection_duration.hours | int > 0 or input_frost_protection_duration.minutes | int > 0 or input_frost_protection_duration.seconds | int > 0 %}
      {% set is_frost_protection_configured = iif(is_frost_protection_configured,is_frost_protection_configured,days in input_frost_protection_duration) %}
      {% set is_person_based = input_persons | count > 0 %}
      {% set is_presence_based = input_presence_sensor != none %}

      {% if is_frost_protection_configured == false or ( is_person_based == false and is_presence_based == false ) %}
        {{ false }}
      {% else %}
        {% set person_fp = false %}
        {% set presence_fp = false %}

        {% set delta = timedelta(**input_frost_protection_duration)%}

        {% if is_person_based %}
          {% set last_person_leaving = input_persons | expand | sort(attribute = 'last_changed', reverse=true) | map(attribute='entity_id') | first %}
          {% set person_fp = (now() - states.person[last_person_leaving.split('.')[1]].last_changed) >= delta %}
        {% endif %}

        {% if is_presence_based %}
          {% set presence_fp = (now() - ([input_presence_sensor] | expand | map(attribute='last_changed') | first)) >= delta %}
        {% endif %}

        {% if is_person_based and is_presence_based %}
          {{ person_fp and presence_fp }}
        {% else %}
          {{ iif(is_person_based, person_fp, presence_fp) }}
        {% endif %}
      {% endif %}
  
# HEATING / COOLING WHEN ABOVE/BELOW ROOM TEMPERATURE
  - platform: template
    id: temperature_change_room_temp_above_target
    value_template: >
        {% if input_temperature_sensor != none and is_heat_only_if_below_real_temp == true %}
          {{ (now() - states.sensor[input_temperature_sensor.split('.')[1]].last_updated) >= timedelta(hours=0, minutes=0, seconds=2) }}
        {% else %}
          {{ false }}
        {% endif %}

##################################################
############### V A R I A B L E S ################
##################################################

variables:
  # I N P U T S
  input_trvs: !input input_trvs
  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_comfort_static: !input input_temperature_comfort_static
  input_temperature_minimum: !input input_temperature_minimum
  input_temperature_minimum_static: !input input_temperature_minimum_static

  #frost protection
  input_frost_protection_temp: !input input_frost_protection_temp
  input_frost_protection_duration: !input input_frost_protection_duration

  # heating scheduler
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector

  input_scheduler_presence: !input input_scheduler_presence

  input_windows: !input input_windows
  input_windows_reaction_time_open: !input input_windows_reaction_time_open
  input_windows_reaction_time_close: !input input_windows_reaction_time_close

  input_mode_winter: !input input_mode_winter
  input_mode_outside_temperature: !input input_mode_outside_temperature
  input_mode_outside_temperature_threshold: !input input_mode_outside_temperature_threshold
  input_proximity: !input input_proximity

  input_mode_party: !input input_mode_party
  input_mode_guest: !input input_mode_guest
  input_force_max_temperature: !input input_force_max_temperature

  input_persons: !input input_persons
  input_people_entering_home_duration: !input input_people_entering_home_duration
  input_people_leaving_home_duration: !input input_people_leaving_home_duration

  input_presence_sensor: !input input_presence_sensor
  input_presence_reaction_off_time: !input input_presence_reaction_off_time
  input_presence_reaction_on_time: !input input_presence_reaction_on_time
  input_temperature_sensor: !input input_temperature_sensor
  input_calibration_delta: !input input_calibration_delta
  input_time_based_temperature_change_valve_target: !input input_time_based_temperature_change_valve_target
  input_service_call_delay: !input input_service_call_delay
  input_aggressive_mode_offset: !input input_aggressive_mode_offset
  input_aggressive_mode_range: !input input_aggressive_mode_range
  input_custom_action: !input input_custom_action
  input_tweaks: !input input_tweaks
  input_calibration_options: !input input_calibration_options
  input_hvac_mode: !input input_hvac_mode
  input_away_offset: !input input_away_offset
  input_away_options: !input input_away_options
  # input_tweaks_experimental: !input input_tweaks_experimental

  # TWEAKS
  is_reset_temperature: "{{ 'reset_temperature' in input_tweaks}}"
  is_off_instead_min: "{{ 'off_instead_min' in input_tweaks}}"
  is_not_off_but_min: "{{ 'not_off_but_min' in input_tweaks}}"
  is_heat_only_if_below_real_temp: "{{ 'heat_only_if_below_real_temp' in input_tweaks}}"
  is_fahrenheit: "{{ 'fahrenheit' in input_tweaks}}"
  is_aggresive_mode: "{{ input_aggressive_mode_range > 0 and input_aggressive_mode_offset > 0 }}"

  is_generic_calibration: "{{ 'generic_calibration' in input_calibration_options}}"
  is_rounded_values: "{{ 'rounded_values' in input_calibration_options}}"

  is_scheduler_away_mode: "{{ 'scheduler' in input_away_options}}"
  is_presence_away_mode: "{{ 'presence' in input_away_options}}"

  # is_physical_temperature_change: "{{ 'physical_temperature_change' in input_tweaks_experimental}}"
  # is_physical_party_timer: "{{ 'physical_party_timer' in input_tweaks_experimental}}"

  # V A L V E   G R O U P S
  valves: "{{ expand(input_trvs) | selectattr('attributes.hvac_modes','search','(?i)'+input_hvac_mode) | map(attribute='entity_id') | list }}"
  valves_unsupported: "{{ input_trvs | reject('in',valves) | list }}"
  valves_off_mode: "{{ valves | expand | selectattr('attributes.hvac_modes','search','(?i)off') | map(attribute='entity_id') | list }}"
  valves_without_off_mode: "{{ valves | reject('in',valves_off_mode) | list }}"

  # E V A L U A T I O N --------------------------------------------------------------

  # ------------------------------------------------------------------------------------
  # ------------- PRESENCE, SCHEDULER, FROST PROTECTION, WINDOWS, PERSONS --------------
  # ------------------------------------------------------------------------------------

  active_party_entity: "{{ input_mode_party | expand | selectattr('state', 'in', ['active','on']) | map(attribute='entity_id') | first | default(none) }}"
  state_mode_party: "{{ active_party_entity != none }}"
  party_temp: > 
    {% set pos_party_temp = none %}
    {% if state_mode_party == true %}
      {% set name = state_attr(active_party_entity,'friendly_name') %}
      {% set pos_temp = name.split(' ') | last %}
      {% if is_number(pos_temp) %}
        {% set pos_party_temp = pos_temp | float %}
      {% endif %}
    {% endif %}
    {{ pos_party_temp }}

  state_mode_guest: "{{ input_mode_guest != none and states(input_mode_guest) in ['on','active'] }}"

  state_mode_winter: >
    {% if input_mode_winter != none %}
      {{ states(input_mode_winter) == 'on' }}
    {% else %}
      {{ true }}
    {% endif %}

  state_outside_temp: >
    {% if input_mode_outside_temperature != none %}
      {% set state = states(input_mode_outside_temperature) %}
      {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}
      {{ state | int <= input_mode_outside_temperature_threshold | int }}
    {% else %}
      {{ true }}
    {% endif %}

  state_force_max_temperature: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'on') }}"
  state_window: >
    {% set on_time_delta = now() - timedelta(**input_windows_reaction_time_open) %}
    {% set off_time_delta = now() - timedelta(**input_windows_reaction_time_close) %}

    {% set result = namespace(r=false) %}

    {% set on_windows = expand(input_windows) | selectattr('state', 'eq', 'on') | map(attribute='entity_id') | list %}
    {% for window in on_windows %}
      {% set last_changed = states.binary_sensor[window.split('.')[1]].last_changed %}
      {% set in_delta = last_changed <= on_time_delta %}
      {% if result.r == false %}
        {% set result.r = in_delta %}
      {% endif %}  
    {% endfor %}

    {% set thermostats_off = namespace(r=false) %}
    {% for thermostat in input_trvs %}
      {% set min_temp = state_attr(thermostat,'min_temp') %}
      {% set current_temp = state_attr(thermostat,'temperature') %}
      {% if current_temp == min_temp %}
        {% set thermostats_off.r = true %}
      {% endif %}
    {% endfor %}

    {% set is_thermostats_off = (expand(input_trvs) | selectattr('state','eq','off') | map(attribute='entity_id') | list | count > 0)
                                or thermostats_off.r %}

    {% if is_thermostats_off %}
      {% set off_windows =  expand(input_windows) | selectattr('state', 'eq', 'off') | map(attribute='entity_id') | list %}
      {% for window in off_windows %}
        {% set last_changed = states.binary_sensor[window.split('.')[1]].last_changed %}
        {% set in_delta = last_changed >= off_time_delta %}
        {% if result.r == false %}
          {% set result.r = in_delta %}
        {% endif %}
      {% endfor %}
    {% endif %}

    {{ result.r }}

  active_scheduler: >
    {% set selected_scheduler = none %}

    {% if input_schedulers | count == 0 %}
      {% set selected_scheduler = none %}
    {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
      {% set selected_scheduler = input_schedulers[0] %}
    {% elif input_schedulers | count > 1 %}
      {% set selected_scheduler = input_schedulers[0] %}
      {% set selector_value = states(input_scheduler_selector) %}

      {% if is_number(selector_value) %}
        {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
        {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
        {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
      {% elif selector_value in ['on','off'] %}
        {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
      {% else %}
        {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'eq', selector_value) | map(attribute='entity_id') | first | default(none) %}
        {% if (selected_scheduler == none) %}
          {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first %}
        {% endif %}
      {% endif %}
    {% endif %}

    {{ selected_scheduler }}

  up_time_sensor: "{{ integration_entities('uptime') | first | default(none) }}"
  # People Configuration
  is_person_based: "{{ input_mode_guest != none or input_persons | count > 0 }}"
  is_anybody_home: >
    {% set on_time_delta = now() - timedelta(**input_people_entering_home_duration) %}
    {% set off_time_delta = now() - timedelta(**input_people_leaving_home_duration) %}

    {% set uptime = now() %}

    {% if up_time_sensor != none %}
      {% set uptime = states(up_time_sensor) | as_datetime %}
    {% endif %}

    {% set uptime_on = uptime + timedelta(**input_people_entering_home_duration) %}
    {% set uptime_off = uptime + timedelta(**input_people_leaving_home_duration) %}

    {% set result = false %}

    {% if (uptime_on > on_time_delta or uptime_off > off_time_delta ) %}

      {% set result = expand(input_persons) | selectattr('state', 'eq', 'home') | map(attribute='entity_id') | list | count > 0 %}

    {% else %}

      {% set result = namespace(r=false) %}

      {% set persons_home = expand(input_persons) | selectattr('state', 'eq', 'home') | map(attribute='entity_id') | list %}
      {% for person in persons_home %}
        {% set last_changed = states.person[person.split('.')[1]].last_changed %}
        {% set in_delta = last_changed <= on_time_delta %}
        {% if result.r == false %}
          {% set result.r = in_delta %}
        {% endif %}  
      {% endfor %}

      {% set persons_not_home = expand(input_persons) | rejectattr('state', 'eq', 'home') | map(attribute='entity_id') | list %}

      {% for person in persons_not_home %}
        {% set last_changed = states.person[person.split('.')[1]].last_changed %}
        {% set in_delta = last_changed >= off_time_delta %}
        {% if result.r == false %}
          {% set result.r = in_delta %}
        {% endif %}
      {% endfor %}

      {% set result = result.r%}

    {% endif %}

    {{ result or state_mode_guest  }}

  # Presence Configuration
  is_presence_sensor_defined: "{{ input_presence_sensor != none }}"
  is_presence_scheduler_defined: "{{ input_scheduler_presence != none }}"
  state_presence_sensor: "{{ is_presence_sensor_defined and is_state(input_presence_sensor, 'on') }}"
  state_presence_scheduler: "{{ is_presence_scheduler_defined and is_state(input_scheduler_presence, 'on') }}"

  state_presence_sensor_presence_scheduler_combined: >
    {% set result = false %}
    {% if is_presence_sensor_defined %}
      {% set result = iif(is_presence_scheduler_defined, state_presence_scheduler and state_presence_sensor, state_presence_sensor) %}
    {% endif %}
    {{ result }}

  is_presence_on: >
    {{ iif(is_person_based, state_presence_sensor_presence_scheduler_combined and is_anybody_home, state_presence_sensor_presence_scheduler_combined) }}

  # Scheduler Configuration
  is_scheduled_heating: "{{ active_scheduler != none }}"
  state_scheduler: "{{ is_scheduled_heating and is_state(active_scheduler,'on') }}"

  is_scheduled_heating_on: >
    {{ iif(is_person_based, state_scheduler and is_anybody_home, state_scheduler) }}

  # Proximity
  is_somebody_on_way_home_state: >
    {% set proximity_entities = device_entities(input_proximity) %}

    {% set is_arrived = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'enum') 
                                              | map(attribute='entity_id') | select('is_state','arrived') 
                                              | list | count > 0 %}

    {% set entities_towards = proximity_entities  | expand 
                                            | selectattr('attributes.device_class', 'eq', 'enum') 
                                            | map(attribute='entity_id') | select('is_state','towards') 
                                            | list %}

    {% set entities_distances = proximity_entities  | expand 
                                            | selectattr('attributes.device_class', 'eq', 'distance')
                                            | map(attribute='entity_id')
                                            | list %}

    {% set result = namespace(is_towards=false) %}
    {% for t in entities_towards %}
      {% set name = t.split('_')[:-1] | join('_') %}
      {% set entities_distances_filtered = entities_distances | expand | selectattr('entity_id','search',name) | map(attribute='entity_id') | list %}
      {% if result.is_towards == false and entities_distances_filtered | count > 0 %}
        {% set result.is_towards = states(entities_distances_filtered | first) | int <= input_proximity_distance | int %}
      {% endif %}
    {% endfor %}
    {% set is_towards = result.is_towards %}

    {{ (is_scheduled_heating == false and is_presence_sensor_defined == false and is_arrived == true) or is_towards == true}}

  is_somebody_on_way_home: >
    {% if is_somebody_on_way_home_state == false %}
      {{ false }}
    {% elif state_scheduler %}
      {{ true }}
    {% elif is_presence_sensor_defined and is_presence_scheduler_defined == false %}
      {{ true }}
    {% elif is_presence_sensor_defined and is_presence_scheduler_defined %}
      {{ state_presence_scheduler }}
    {% elif is_presence_sensor_defined == false and is_person_based and is_scheduled_heating == false %}
      {{ true }}
    {% else %}
      {{ is_somebody_on_way_home_state }}
    {% endif %}

  is_presence_based: >
    {{ input_presence_sensor != none }}

  is_frost_protection: >
    {% set is_frost_protection_configured = input_frost_protection_duration.hours | int > 0 or input_frost_protection_duration.minutes | int > 0 or input_frost_protection_duration.seconds | int > 0 %}
    {% set is_frost_protection_configured = iif(is_frost_protection_configured,is_frost_protection_configured,days in input_frost_protection_duration) %}
    {% set is_person_based = input_persons | count > 0 %}

    {% if is_frost_protection_configured == false or ( is_person_based == false and is_presence_based == false ) %}
      {{ false }}
    {% else %}
      {% set person_fp = false %}
      {% set presence_fp = false %}

      {% set delta = timedelta(**input_frost_protection_duration)%}

      {% if is_person_based %}
        {% set last_person_leaving = input_persons | expand | sort(attribute = 'last_changed', reverse=true) | map(attribute='entity_id') | first %}
        {% set person_fp = (now() - states.person[last_person_leaving.split('.')[1]].last_changed) >= delta %}
      {% endif %}

      {% if is_presence_based %}
        {% set presence_fp = (now() - ([input_presence_sensor] | expand | map(attribute='last_changed') | first)) >= delta %}
      {% endif %}

      {% if is_person_based and is_presence_based %}
        {{ person_fp and presence_fp }}
      {% else %}
        {{ iif(is_person_based, person_fp, presence_fp) }}
      {% endif %}
    {% endif %}

  # ------------------------------------------------------------------------------------
  # ----------------------------- TIME BASED MODIFIERS ---------------------------------
  # ------------------------------------------------------------------------------------

  entry: >
    {% set plan = input_time_based_temperature_change_valve_target | rejectattr('time', 'undefined') | list %}
    {% set day = now().strftime('%a') %}
    {% set current_time = now().strftime('%H%M') | int %}
    {% set result = namespace(entry=none,last_entry=none) %}

    {% for e in plan %}
      {% if 'days' in e.keys() and day not in e['days'] %}
        {% set e = none %}
      {% endif %}

      {% if e != none and 'scheduler' in e.keys() and 
            active_scheduler != none and 
            state_attr(active_scheduler,'friendly_name') != e['scheduler'] %}
        {% set e = none %}
      {% endif %}

      {% if e != none%}
        {% set e_time = e['time'].replace(':','') | int %}
        
        {% if e_time <= current_time and
              (result.entry == none or 
                e_time >= result.entry['time'].replace(':','') | int) %}
          {% set result.entry = e %}
        {% elif result.last_entry == none or
                e_time >= result.last_entry['time'].replace(':','') | int %}
          {% set result.last_entry = e %}
        {% endif %}
      {% endif %}
    {% endfor %}
      
    {{ iif(result.entry == none, result.last_entry, result.entry) }}

  entry_time: >
    {% if (entry is defined) and entry  %}
      {% set entry_hour = entry['time'].split(':')[0] | int %}
      {% set entry_minute = entry['time'].split(':')[1] | int %}
      {{ now().replace(hour=entry_hour, minute=entry_minute, second=0, microsecond=0) }}
    {% endif %}

  entry_comfort_temp: >
    {% if (entry is defined) and entry and 'comfort' in entry.keys() %}
      {{ entry['comfort'] }}
    {% else %}
      {{ none }}
    {% endif %}

  entry_eco_temp: >
    {% if (entry is defined) and entry and 'eco' in entry.keys() %}
      {{ entry['eco'] }}
    {% else %}
      {{ none }}
    {% endif %}

  entry_calibration: >
    {% if (entry is defined) and entry and 'calibration' in entry.keys() %}
      {{ entry['calibration'] == 'on' }}
    {% else %}
      {{ true }}
    {% endif %}

  new_comfort_temperature: >
    {% if trigger.id == 'hastart' and entry_comfort_temp != none %}
      {{ entry_comfort_temp }}
    {% elif entry_comfort_temp != none and input_temperature_comfort == none %}
      {{ entry_comfort_temp }}
    {% elif entry_comfort_temp != none and 
            input_temperature_comfort != none and 
            as_timestamp(states.input_number[input_temperature_comfort.split('.')[1]].last_changed) < as_timestamp(entry_time,0) %}
      {{ entry_comfort_temp }}
    {% else %}
      {{ none }}
    {% endif %}

  new_eco_temperature: >
    {% if trigger.id == 'hastart' and entry_eco_temp != none %}
      {{ entry_eco_temp }}
    {% elif entry_eco_temp != none and input_temperature_minimum == none %}
      {{ entry_eco_temp }}
    {% elif entry_comfort_temp != none and 
            input_temperature_minimum != none and 
            as_timestamp(states.input_number[input_temperature_minimum.split('.')[1]].last_changed) < as_timestamp(entry_time,0) %}
      {{ entry_eco_temp }}
    {% else %}
      {{ none }}
    {% endif %}

  # T R V - V A L U E S
  is_heat_only_if_diff: >
    {% if is_temp_higher_lower_target == true and input_temperature_sensor != none and mode in ['cool','heat'] %}
      {{ iif(input_hvac_mode == 'cool', states(input_temperature_sensor) < temperature, states(input_temperature_sensor) > temperature) }}
    {% else %}
      {{ false }}
    {% endif %}

  set_comfort: >
    {% if state_mode_party == true or is_somebody_on_way_home %}
      {{ true }}
    {% elif is_person_based and is_presence_sensor_defined == false and is_scheduled_heating == false %}
      {{ is_anybody_home }}
    {% else %}
      {{ is_scheduled_heating_on or is_presence_on }}
    {% endif %}

  state_temperature_comfort: >
    {% if party_temp != none %}
      {{ party_temp }}
    {% elif input_temperature_comfort != none %}
      {{ states(input_temperature_comfort) }}
    {% elif new_comfort_temperature != none and new_comfort_temperature != '' %}
        {{ new_comfort_temperature }}
    {% else %}
      {{ input_temperature_comfort_static }}
    {% endif %}

  is_away_temperature: >
    {% set result = false %}
    {% if is_person_based and input_hvac_mode in ['cool','heat'] %}
      {% if is_scheduled_heating and is_scheduler_away_mode %}
        {% set result = state_scheduler and is_anybody_home == false %}
      {% endif %}
      {% if result == false and is_presence_based and is_presence_away_mode %}
        {% set result = is_anybody_home == true and state_presence_sensor_presence_scheduler_combined == false %}
      {% endif %}
    {% endif %}
    {{ result }}

  state_temperature_min: >
    {% if is_frost_protection %}
      {{ input_frost_protection_temp }}
    {% else %}
      {% set min_temp = input_temperature_minimum_static %}

      {% if input_temperature_minimum != none %}
        {% set min_temp = states(input_temperature_minimum) %}
      {% elif new_eco_temperature != none and new_eco_temperature != '' %}
        {% set min_temp = new_eco_temperature %}
      {% endif %}

      {% if is_away_temperature %}
        {% set faktor = iif(input_hvac_mode == 'heat', -1, 1) %}
        {% set min_temp = state_temperature_comfort | float + input_away_offset | float * faktor %}
      {% endif %}

      {{ min_temp }}
    {% endif %}

  temperature: >
    {{ iif(set_comfort, state_temperature_comfort, state_temperature_min) | float }}

  mode: >
    {% set heating_mode = 'off' %}

    {% if state_force_max_temperature == true %}
      {% set heating_mode = input_hvac_mode %}
    {% elif state_mode_winter == false or state_outside_temp == false or state_window == true %}
      {% set heating_mode = 'off' %}
    {% elif set_comfort == false %}
      {% set heating_mode = iif(is_off_instead_min == true, 'off', input_hvac_mode) %}
    {% elif set_comfort == true %}
      {% set heating_mode = input_hvac_mode %}
    {% endif %}

    {% if is_heat_only_if_below_real_temp == true and 
          input_temperature_sensor != none and 
          heating_mode in ['cool','heat'] %}
      {% set sensor_temp = states(input_temperature_sensor) | float %}

      {% if heating_mode == 'cool' and sensor_temp < temperature %}
        {% set heating_mode = 'off' %}
      {% elif heating_mode == 'heat' and sensor_temp > temperature %}
        {% set heating_mode = 'off' %}
      {% endif %}
    {% endif %}

    {{ heating_mode }}

  is_physical_change: >
    {{ false }}
  # is_physical_change: >
  #   {{
  #     trigger.id == 'temperature_change_valve_target' and
  #     trigger.to_state.context.id != none and
  #     trigger.to_state.context.parent_id == none and
  #     trigger.to_state.context.user_id == none and
  #     is_physical_temperature_change == true
  #   }}

  # is_automation_change: >
  #   {{
  #     trigger.id == 'temperature_change_valve_target' and
  #     trigger.to_state.context.id != none and
  #     trigger.to_state.context.parent_id != none and
  #     trigger.to_state.context.user_id == none
  #   }}

  # is_ui_change: >
  #   {{
  #     trigger.id == 'temperature_change_valve_target' and
  #     trigger.to_state.context.id != none and
  #     trigger.to_state.context.parent_id == none and
  #     trigger.to_state.context.user_id != none
  #   }}

  is_manual_timer_start: >
    {{ false }}
  # is_manual_timer_start: >
  #   {{
  #     trigger.id == 'temperature_change_valve_target' and
  #     trigger.to_state.context.id != none and
  #     trigger.to_state.context.parent_id == none and
  #     trigger.to_state.context.user_id == none and
  #     is_physical_party_timer == true and
  #     input_mode_party != none and
  #     input_mode_party.split('.')[0] == 'timer' and
  #     state_mode_party == false
  #   }}

  is_reset: >
    {{
      input_temperature_comfort != none and
      float(states(input_temperature_comfort)) != float(input_temperature_comfort_static) and
      (
        trigger.id in ['temperature_change_party_off'] or
        (trigger.id in ['temperature_change_scheduler_off',
                        'temperature_change_person_off',
                        'temperature_change_person_guest_off',
                        'temperature_change_presence_off'] and
        set_comfort == false)
      ) and
      is_reset_temperature == true
    }}

  # EVLAUATING TRIGGER IDs
  is_calibration: >
    {{
      trigger.platform != none and
      mode != 'off' and
      'calibration' in trigger.id and
      input_temperature_sensor != none
    }}

  # ------------------------------------------------------------------------------------
  # ----------------------------- CHANGES & CALIBRATION --------------------------------
  # ------------------------------------------------------------------------------------

  is_refresh_comfort_entity: >
    {{ input_temperature_comfort != none and 
        new_comfort_temperature != none and
        new_comfort_temperature | float != states(input_temperature_comfort) | float }}

  is_refresh_eco_entity: >
    {{ input_temperature_minimum != none and 
        new_eco_temperature != none and
        new_eco_temperature | float != states(input_temperature_minimum) | float }}

  is_temperature_change: >
    {{  
        trigger.platform == none or
        "temperature_change" in trigger.id or 
        is_calibration and is_generic_calibration or 
        is_aggresive_mode and "aggressive_mode" in trigger.id
    }}

  changes: >
    {% set n = namespace(dict=[]) %}

    {% if is_temperature_change == false %}
      {{ n.dict }}
    {% else %}
      {% for valve in input_trvs %}

        {% set current_valve_temp = state_attr(valve, 'current_temperature') | float(20) %}
        {% set current_valve_target_temp = state_attr(valve, 'temperature') | float(temperature) %}
        {% set current_valve_mode = states(valve) %}
        {% set min_temp = state_attr(valve, 'min_temp') | float(5) %}
        {% set max_temp = state_attr(valve, 'max_temp') | float(30) %}

        {% set valve_mode = iif(mode == 'off' and (valve in valves_without_off_mode or is_not_off_but_min), current_valve_mode, mode) %}
        {% set valve_temp = temperature %}
        {% set valve_temp = iif((valve in valves_without_off_mode or is_not_off_but_min) and mode == 'off', min_temp, temperature) %}
        {% set valve_temp = iif(state_force_max_temperature and mode != 'off', max_temp, valve_temp) %}

        {% if mode != 'off' %}

          {% if is_aggresive_mode %}
            {% set temp_diff = valve_temp - current_valve_temp %}

            {% if temp_diff < input_aggressive_mode_range * -1 %}
              {% set valve_temp = valve_temp - input_aggressive_mode_offset %}
            {% elif temp_diff > input_aggressive_mode_range %}
              {% set valve_temp = valve_temp + input_aggressive_mode_offset %}
            {% endif %}

            {% if valve_temp < min_temp %}
              {% set valve_temp = min_temp %}
            {% elif valve_temp > max_temp %}
              {% set valve_temp = max_temp %}
            {% endif %}

          {% endif %}

          {% if is_generic_calibration and input_temperature_sensor != none %}

            {% set sensor_temp = states(input_temperature_sensor) | float(current_valve_temp) %}

            {% if current_valve_temp != sensor_temp %}
              {% set offset = sensor_temp - current_valve_temp %}
              {% if(offset > 2) %}
                {% set offset = 2 %}
              {% elif (offset < -2) %}
                {% set offset = -2 %}
              {% endif %}

              {% set temp_with_offset = float(valve_temp) - float(offset) %}
              {% set step = state_attr(valve, 'target_temp_step') | float(0.5) %}

              {% set temp_with_offset = (temp_with_offset | float(0) / float(step)) | round(0) * float(step) %}

              {% if(temp_with_offset > max_temp) %}
                {% set temp_with_offset = max_temp %}
              {% elif (temp_with_offset < min_temp) %}
                {% set temp_with_offset = min_temp %}
              {% endif %}

              {% set valve_temp = iif(is_rounded_values == true, float(temp_with_offset) | round(), temp_with_offset | round(1)) %}

            {% endif %}
          {% endif %}

        {% endif %}

        {% if (current_valve_mode != valve_mode or 
            current_valve_target_temp != valve_temp) and valve not in valves_unsupported %}
          {% set n.dict = n.dict + [(valve, [{'mode': valve_mode , 'temp': valve_temp}])] %}
        {% endif %}

      {% endfor %}

      {{ dict.from_keys(n.dict) }}
    {% endif %}
  # --------------------------------------------
  # CALIBRATION --------------------------------
  # --------------------------------------------

  VAR_UNIT_OF_MEASUREMENT: "unit_of_measurement"

  is_metric: "{{ input_temperature_sensor == none or (input_temperature_sensor != none and state_attr(input_temperature_sensor,VAR_UNIT_OF_MEASUREMENT) == '°C') }}"

  rounding: "{{ iif(is_rounded_values, 0, 2) | int }}"

  # TADO
  valves_tado: "{{ valves | select('is_device_attr', 'manufacturer', 'Tado') | list }}"
  calibration_tado: >
    {% set n = namespace(dict=[]) %}

    {% if is_calibration and is_generic_calibration == false and entry_calibration %}
      {% for valve in valves_tado %}

        {% set offset_old = state_attr(valve, iif(is_metric, 'offset_celsius', 'offset_fahrenheit')) | float(0) %}
        {% set local_temperature = state_attr(valve, 'current_temperature') | float %}
        {% set calibration_sensor_temperature = states(input_temperature_sensor) %}

        {% set offset = float(calibration_sensor_temperature) - float(local_temperature) %}
        {% set offset_new = (float(offset) + float(offset_old)) | round(rounding | int) %}

        {% if (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) %}
          {% set n.dict = n.dict + [(valve, [{'value': offset_new}])] %}
        {% endif %}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  # XIAOMI / AQARA
  valves_xiaomi_xiaomi: "{{ valves | select('is_device_attr', 'manufacturer', 'Xiaomi') | list }}"
  valves_xiaomi_aqara: "{{ valves | select('is_device_attr', 'manufacturer', 'Aqara') | list }}"
  valves_xiaomi: "{{ valves_xiaomi_xiaomi + valves_xiaomi_aqara }}"
  calibration_xiaomi: >
    {% set n = namespace(dict=[]) %}

    {% if is_calibration and is_generic_calibration == false and entry_calibration %}
      {% for valve in valves_xiaomi %}

        {% set calibration_entities = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    map(attribute='entity_id') | list %}

        {% if calibration_entities | count > 0 %}

          {% set calibration_entity = calibration_entities | first %}
          {% set offset_old = states(calibration_entity) | float(0) %}
          {% set offset_new = states(input_temperature_sensor) | float %}

          {% if (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) %}
            {% set n.dict = n.dict + [(calibration_entity, [{'value': offset_new, 'valve': valve}])] %}
          {% endif %}
        {% endif %}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  # DANFOSS, POPP, HIVE
  valves_danfoss: "{{ valves | select('is_device_attr', 'manufacturer', 'Danfoss') | list }}"
  valves_popp: "{{ valves | select('is_device_attr', 'manufacturer', 'Popp') | list }}"
  valves_hive: "{{ valves | select('is_device_attr', 'manufacturer', 'Hive') | list }}"
  valves_external_sensor: "{{ valves_danfoss + valves_popp + valves_hive }}"

  is_periodical_popp_calibration: >
    {{ trigger.id in ['calibration_popp_ping','hastart','reload'] }}

  is_difference_popp_calibration: >
    {{ trigger.id in ['calibration_popp_change'] }}

  calibration_external_sensor: >
    {% set n = namespace(dict=[]) %}
    {% if (is_periodical_popp_calibration or is_difference_popp_calibration) and is_generic_calibration == false and entry_calibration %}
      
      {% for valve in valves_external_sensor %}

        {% set calibration_entity = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    selectattr('entity_id', 'search', 'external') |
                                    map(attribute='entity_id') | first %}

        {% set calibration_sensor_temperature = states(input_temperature_sensor) | float %}
        {% set new_state = (calibration_sensor_temperature | float(0) * 100) | int %}
        {% set old_state = states(calibration_entity) | int %}

        {% set update_calibration = false %}

        {% if is_periodical_popp_calibration %}
          {% set last_updated = [calibration_entity] | expand | map(attribute='last_updated') | first %}
          {% set update_calibration = now() - timedelta(minutes=20) >= last_updated %}
        {% endif %}

        {% if is_difference_popp_calibration %}
          {% set update_calibration = old_state != new_state %}
        {% endif %}
        
        {% if update_calibration %}
          {% set n.dict = n.dict + [(calibration_entity, [{'value': new_state, 'valve': valve}])] %}
        {% endif%}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  # COMMON CALIBRATION e.g. TUYA
  valves_calibration_common: "{{ valves | reject('in', valves_tado + valves_external_sensor + valves_xiaomi) | list }}"
  calibration_common: >
    {% set n = namespace(dict=[]) %}

    {% if is_calibration and is_generic_calibration == false and entry_calibration %}
      
      {% for valve in valves_calibration_common %}

        {% set calibration_entities = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    selectattr('entity_id', 'search', 'offset') |
                                    map(attribute='entity_id') | list %}

        {% if calibration_entities | count == 0 %}
          {% set calibration_entities = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    selectattr('entity_id', 'search', 'calibration') |
                                    map(attribute='entity_id') | list %}
        {% endif %}

        {% if calibration_entities | count > 0 %}

          {% set calibration_entity = calibration_entities | first %}
          {% set step = state_attr(calibration_entity, 'step') | float %}
          {% set min_calibration_value = state_attr(calibration_entity,'min') | float %}
          {% set max_calibration_value = state_attr(calibration_entity,'max') | float %}
          {% set thermostat_temperature = state_attr(valve, 'current_temperature') | float %}
          {% set calibration_sensor_temperature = states(input_temperature_sensor) | float %}
          {% set offset_old = states(calibration_entity) | float(0) %}

          {% set new_calibration_value = calibration_sensor_temperature - (thermostat_temperature - offset_old) %}

          {% set new_calibration_value = iif(new_calibration_value > max_calibration_value, max_calibration_value, new_calibration_value) %}
          {% set new_calibration_value = iif(new_calibration_value < min_calibration_value, min_calibration_value, new_calibration_value) %}
          
          {% set round_size = iif('.' in (step | string) and is_rounded_values == false, (step | string).split('.')[1] | length, 0) %}

          {% set offset_new = ((new_calibration_value | float(0) / step) | round(0) * step) | round(round_size) | float %}
          

          {% if (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) %}
            {% set n.dict = n.dict + [(calibration_entity, [{'value': offset_new, 'valve': valve}])] %}
          {% endif %}

        {% endif %}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  calibration_number: "{{ dict(dict(calibration_xiaomi, **calibration_external_sensor),**calibration_common) }}"

  is_heating: "{{ set_comfort and mode != 'off' }}"

  is_warning: "{{ valves_unsupported | count > 0 }}"

##################################################
########### C O N D I T I O N S ##################
##################################################

condition:
  - condition: or
    conditions:
      - condition: template
        value_template: "{{ is_warning }}"
      - condition: template
        value_template: "{{ calibration_number | count > 0 }}"
      - condition: template
        value_template: "{{ calibration_tado | count > 0 }}"
      - condition: template
        value_template: "{{ changes | count > 0 }}"
      - condition: template
        value_template: "{{ is_manual_timer_start }}"
      - condition: template
        value_template: "{{ is_reset }}"
      - condition: template
        value_template: "{{ is_refresh_comfort_entity or is_refresh_eco_entity or is_temperature_change }}"

##################################################
################## A C T I O N ###################
##################################################

action:
  - if:
      - condition: template
        value_template: "{{ trigger.id in ['hastart'] }}"
    then:
      - delay:
          seconds: 10

  - if:
      - condition: template
        value_template: "{{ valves_unsupported | count > 0 }}"
    then:
      - service: system_log.write
        data:
          level: warning
          logger: blueprints.panhans.heatingcontrol
          message: > 
            AHC - Your selected hvac mode {{ input_hvac_mode }} isn't support by some of your climate entities: {{ valves_unsupported | join(', ') }}

  - if:
      - condition: template
        value_template: "{{ up_time_sensor == none }}"
    then:
      - service: system_log.write
        data:
          level: warning
          logger: blueprints.panhans.heatingcontrol
          message: AHC - To make Advance Heating Control work properly just setup the Uptime integration.

  - if:
      - condition: template
        value_template:
          "{{ (is_generic_calibration or (input_aggressive_mode_range > 0 and input_aggressive_mode_offset > 0))
          and is_physical_change }}"
    then:
      - service: system_log.write
        data:
          level: warning
          logger: blueprints.panhans.heatingcontrol
          message: >
            AHC - You've enabled generic calibration / aggressive mode in combination with the physical change feature. 
            Unwanted side effects may occur with this configuration. This combination is therefore not recommended.

  - service: system_log.write
    data:
      message: >
        AHC REF  {{" \n "}}
        {{" \n "}}
        TRIGGER {{" \n "}}
        is_calibration: {{ calibration_number | count > 0 or calibration_tado | count > 0 }} {{" \n "}}
        is_changes: {{ changes | count > 0 }} {{" \n "}}
        is_reset: {{ is_reset }} {{" \n "}}
        is_refresh_comfort_entity: {{ is_refresh_comfort_entity or is_refresh_eco_entity }} {{" \n "}}
        {{" \n "}}
        proximity: {{ input_proximity }} {{ " \n " }}
        is_somebody_on_way_home_state: {{ is_somebody_on_way_home_state }} {{ " \n " }}
        proximity_entities: {{ device_entities(input_proximity) }} {{ " \n " }}
        entry: {{ entry }} {{ " \n " }}
        entry_time: {{ entry_time }} {{ " \n " }}
        entry_comfort_temp: {{ entry_comfort_temp }} {{ " \n " }}
        new_comfort_temperature: {{ new_comfort_temperature }} {{ " \n " }}
        is_refresh_comfort_entity: {{ is_refresh_comfort_entity }} {{ " \n " }}
        state_mode_winter: {{ state_mode_winter }} {{ " \n " }}
        state_mode_party: {{ state_mode_party }} {{ " \n " }}
        state_mode_guest: {{ state_mode_guest }} {{ " \n " }}
        state_outside_temp: {{ state_outside_temp }} {{ " \n " }}
        state_force_max_temperature: {{ state_force_max_temperature }} {{ " \n " }}
        state_window: {{ state_window }} {{ " \n " }}
        state_temperature_comfort: {{ state_temperature_comfort }} {{ " \n " }}
        active_scheduler: {{ active_scheduler }} {{ " \n " }}
        is_person_based: {{ is_person_based }} {{ " \n " }}
        is_anybody_home: {{ is_anybody_home }} {{ " \n " }}
        is_somebody_on_way_home_state: {{ is_somebody_on_way_home_state }} {{ " \n " }}
        is_presence_sensor_defined: {{ is_presence_sensor_defined }} {{ " \n " }}
        is_presence_scheduler_defined: {{ is_presence_scheduler_defined }} {{ " \n " }}
        state_presence_sensor: {{ state_presence_sensor }} {{ " \n " }}
        state_presence_scheduler: {{ state_presence_scheduler }} {{ " \n " }}
        is_presence_on: {{ is_presence_on }} {{ " \n " }}
        is_scheduled_heating: {{ is_scheduled_heating }} {{ " \n " }}
        state_scheduler: {{ state_scheduler }} {{ " \n " }}
        is_scheduled_heating_on: {{ is_scheduled_heating_on }} {{ " \n " }}
        is_somebody_on_way_home: {{ is_somebody_on_way_home }} {{ " \n " }}
        is_frost_protection: {{ is_frost_protection }} {{ " \n " }}
        state_temperature_min: {{ state_temperature_min }} {{ " \n " }}
        set_comfort: {{ set_comfort }} {{ " \n " }}
        mode: {{ mode }} {{ " \n " }}
        temperature: {{ temperature }} {{ " \n " }}
        is_physical_change: {{ is_physical_change }} {{ " \n " }}
        is_calibration: {{ is_calibration }} {{ " \n " }}
        changes: {{ changes }} {{ " \n " }}
        valves_tado: {{ valves_tado }} {{ " \n " }}
        calibration_tado: {{ calibration_tado }} {{ " \n " }}
        valves_xiaomi: {{ valves_xiaomi }} {{ " \n " }}
        calibration_xiaomi: {{ calibration_xiaomi }} {{ " \n " }}
        valves_external_sensor: {{ valves_external_sensor }} {{ " \n " }}
        calibration_external_sensor: {{ calibration_external_sensor }} {{ " \n " }}
        valves_calibration_common: {{ valves_calibration_common }} {{ " \n " }}
        calibration_common: {{ calibration_common }} {{ " \n " }}
        is_heating: {{ is_heating }} {{ " \n " }}
        is_metric: {{ is_metric }} {{ " \n " }}
        input_hvac_mode in ['cool','heat']: {{ input_hvac_mode in ['cool','heat'] }}
      level: !input input_log_level
      logger: blueprints.panhans.heatingcontrol

  - choose:
      # TIMER STOP RESET
      - conditions:
          - condition: template
            value_template: "{{ is_reset }}"
        sequence:
          - service: input_number.set_value
            data:
              value: "{{ input_temperature_comfort_static }}"
            target:
              entity_id: !input input_temperature_comfort

    default:
      # UPDATE TEMPERATURE ENTITIES
      - if: # COMFORT ENTITY
          - condition: template
            value_template: "{{ input_temperature_comfort != none and
              (is_refresh_comfort_entity) }}"
        then:
          - variables:
              max_comfort_temp: "{{ state_attr(input_temperature_comfort,'max') | float }}"
              min_comfort_temp: "{{ state_attr(input_temperature_comfort,'min') | float }}"

              new_manual_temp: >
                {% if is_refresh_comfort_entity %}
                  {{ new_comfort_temperature | float }}
                {% else %}
                  {{ temperature_change_temperature }}
                {% endif %}
              real_manual_temp: >
                {% if (new_manual_temp > max_comfort_temp) %}
                  {{ max_comfort_temp }}
                {% elif (new_manual_temp < min_comfort_temp) %}
                  {{ min_comfort_temp }}
                {% else %}
                  {{ new_manual_temp }}
                {% endif %}

          - condition: template
            value_template: "{{  real_manual_temp != state_temperature_comfort }}"

          - service: input_number.set_value
            data:
              value: "{{ real_manual_temp }}"
            target:
              entity_id: !input input_temperature_comfort

      - if: #ECO ENTITY
          - condition: template
            value_template: "{{ input_temperature_minimum != none and
              is_refresh_eco_entity }}"
        then:
          - variables:
              max_eco_temp: "{{ state_attr(input_temperature_minimum,'max') | float }}"
              min_eco_temp: "{{ state_attr(input_temperature_minimum,'min') | float }}"

              new_manual_temp: >
                {% if is_refresh_eco_entity %}
                  {{ new_eco_temperature | float }}
                {% else %}
                  {{ temperature_change_temperature }}
                {% endif %}
              real_manual_temp: >
                {% if (new_manual_temp > max_eco_temp) %}
                  {{ max_eco_temp }}
                {% elif (new_manual_temp < min_eco_temp ) %}
                  {{ min_eco_temp }}
                {% else %}
                  {{ new_manual_temp }}
                {% endif %}

          - condition: template
            value_template: "{{  real_manual_temp != state_temperature_comfort }}"

          - service: input_number.set_value
            data:
              value: "{{ real_manual_temp }}"
            target:
              entity_id: !input input_temperature_minimum

      - if: # MANUAL TIMER START
          - condition: template
            value_template: "{{ is_manual_timer_start }}"
        then:
          - service: timer.start
            target:
              entity_id: "{{ input_mode_party }}"
          - delay:
              hours: "{{ input_service_call_delay.hours }}"
              minutes: "{{ input_service_call_delay.minutes }}"
              seconds: "{{ input_service_call_delay.seconds }}"

      # NUMBER CALIBRATION
      - repeat:
          count: "{{ calibration_number | count | int }}"
          sequence:
            - variables:
                index: "{{ repeat.index-1 }}"
                calibration_entity: "{{ (calibration_number.keys() | list) [index] }}"
                thermostat: "{{ (((calibration_number.values() | list) [index]) | first) ['valve'] }}"
                offset: "{{ (((calibration_number.values() | list) [index]) | first) ['value'] }}"

            - service: system_log.write
              data:
                message: >
                  AHC REF CALIBRATION  {{" \n "}}
                  calibration entity: {{ calibration_entity }}  {{" \n "}}
                  offset: {{ offset }}
                level: !input input_log_level
                logger: blueprints.panhans.heatingcontrol

            - service: number.set_value
              data:
                value: "{{ float(offset) }}"
              target:
                entity_id: "{{ calibration_entity }}"
            - delay:
                hours: "{{ input_service_call_delay.hours }}"
                minutes: "{{ input_service_call_delay.minutes }}"
                seconds: "{{ input_service_call_delay.seconds }}"

      # TADO CALIBRATION
      - repeat:
          count: "{{ calibration_tado | count | int }}"
          sequence:
            - variables:
                index: "{{ repeat.index-1 }}"
                thermostat: "{{ (calibration_tado.keys() | list) [index] }}"
                offset: "{{ (((calibration_tado.values() | list) [index]) | first) ['value'] }}"
            - service: tado.set_climate_temperature_offset
              data:
                offset: "{{ offset }}"
                entity_id: "{{ thermostat }}"
            - delay:
                hours: "{{ input_service_call_delay.hours }}"
                minutes: "{{ input_service_call_delay.minutes }}"
                seconds: "{{ input_service_call_delay.seconds }}"

      # SET TEMPERATURE
      - service: system_log.write
        data:
          message: >
            AHC REF  {{" \n "}}
            change_count: {{ changes | count | int }}  {{" \n "}}
            changes: {{ changes }}
          level: !input input_log_level
          logger: blueprints.panhans.heatingcontrol
      - repeat:
          count: "{{ changes | count | int }}"
          sequence:
            - variables:
                index: "{{ repeat.index-1 }}"
                thermostat: "{{ (changes.keys() | list) [index] }}"
                mode: "{{ (((changes.values() | list) [index]) | first) ['mode'] }}"
                target_temperature: "{{ (((changes.values() | list) [index]) | first) ['temp'] }}"
            - service: system_log.write
              data:
                message: >
                  thermostat: {{ thermostat }}
                  mode: {{ mode }}
                  new_target: {{ target_temperature }}
                  current_target: {{ state_attr(thermostat,'temperature') }}
                level: !input input_log_level
                logger: blueprints.panhans.heatingcontrol

            - service: system_log.write
              data:
                message: >
                  AHC REF CHANGES: {{ thermostat }} -> {{ mode }} -> {{ target_temperature }}
                level: !input input_log_level
                logger: blueprints.panhans.heatingcontrol

            - if:
                - condition: template
                  value_template: "{{ states(thermostat) | lower != mode | lower  }}"
              then:
                - service: climate.set_hvac_mode
                  data:
                    entity_id: "{{ thermostat }}"
                    hvac_mode: "{{ mode }}"

                - delay:
                    hours: "{{ input_service_call_delay.hours }}"
                    minutes: "{{ input_service_call_delay.minutes }}"
                    seconds: "{{ input_service_call_delay.seconds }}"

            - if:
                - condition: template
                  value_template: "{{ state_attr(thermostat, 'temperature') != target_temperature and mode != 'off' }}"
              then:
                - service: climate.set_temperature
                  data:
                    entity_id: "{{ thermostat }}"
                    temperature: "{{ target_temperature | float }}"

                - delay:
                    hours: "{{ input_service_call_delay.hours }}"
                    minutes: "{{ input_service_call_delay.minutes }}"
                    seconds: "{{ input_service_call_delay.seconds }}"

      - event: ahc_event
        event_data:
          automation: "{{ this.entity_id }}"
          target_temperature: "{{ temperature }}"
          comfort_temperature: "{{ state_temperature_comfort }}"
          eco_temperature: "{{ state_temperature_min }}"
          mode: "{{ mode }}"
          is_comfort: "{{ is_heating }}"
          is_away_temperature: "{{ is_away_temperature }}"
          is_somebody_on_way_home_state: "{{ is_somebody_on_way_home_state }}"
          is_party: "{{ state_mode_party }}"
          is_guest: "{{ state_mode_guest }}"
          is_window_open: "{{ state_window }}"
          active_scheduler: "{{ active_scheduler }}"
          state_scheduler: "{{ state_scheduler }}"
          is_person_based: "{{ is_person_based }}"
          is_presence_based: "{{ is_presence_based }}"
          state_presence_sensor_presence_scheduler_combined: "{{ state_presence_sensor_presence_scheduler_combined }}"
          is_anybody_home: "{{ is_person_based and is_anybody_home }}"
          state_presence_sensor: "{{ state_presence_sensor and is_presence_scheduler_defined }}"
          state_presence_scheduler: "{{ is_presence_scheduler_defined and state_presence_scheduler }}"
          is_presence_on: "{{ is_presence_on }}"
          is_frost_protection: "{{ is_frost_protection }}"
          is_change: "{{ changes | count > 0 }}"
          is_calibration: "{{ is_calibration }}"
          is_force_max_temperature: "{{ state_force_max_temperature }}"

      - if:
          - condition: template
            value_template: "{{ input_custom_action != none }}"
        then: !input "input_custom_action"

mode: queued